<!-- b6263377-7a9b-4e86-ad5b-d87126e381cc b956f00c-12d0-48bd-b27c-94400919f266 -->

# Symbol UUID Refactor Plan

## Phase 0 – Discovery & Design

- Review current `supabase/migrations` history and `types/database.types.ts` to confirm schema/relationship details for `symbols` usage.
- Draft ER diagram + schema spec in `docs/SYMBOL-UUID-PLAN.md` (UUID column, constraints, index strategy, alias table shape, cascade behavior).
- Identify all downstream consumers (SQL views/RPCs, server modules under `server/`, `types/`, CSV importers, cron jobs) that depend on ticker PKs.

## Phase 1 – Database Migrations & Backfill

- Create migration adding `id uuid default gen_random_uuid()` to `symbols`, populating existing rows, and setting as primary key while retaining `ticker text unique`.
- Add `symbol_aliases` table with `(id uuid, symbol_id uuid FK, value text, type text, source text, effective_from timestamptz, effective_to timestamptz, is_primary boolean)` plus unique `(symbol_id, type, value, effective_to)` guard.
- Add nullable `symbol_id uuid` columns to dependent tables (`positions`, `portfolio_records`, `quotes`, `dividends`, `news`, snapshot tables, analytics caches, CSV staging) plus supporting indexes.
- Run backfill scripts (migration-safe) to populate new UUID FKs by joining on legacy ticker, then flip columns to `not null` and enforce foreign keys.
- Drop legacy FK constraints referencing ticker PK, keep ticker column for metadata, and ensure RLS policies reference UUIDs.

## Phase 2 – Tooling & Types

- Regenerate Supabase types (`npm run supabase:types` or equivalent) and update generated files under `types/supabase.ts`.
- Refresh Zod schemas, shared interfaces (e.g., `types/symbol.ts`) to include UUID identifiers and alias metadata.
- Update fixtures/seeds/tests relying on ticker PK assumptions.

## Phase 3 – Resolver Layer & Server Refactor

- Implement `server/symbols/symbol-resolver.ts` exposing helpers (`resolveSymbolAlias`, `getCanonicalSymbol`, `ensurePrimaryAlias`, `setPrimaryAlias`), grounding lookups in `symbol_aliases`.
- When promoting a new primary alias, ensure resolver write-through updates `symbols.ticker` (or refreshes cached view) so downstream reads stay in sync.
- Refactor data ingress paths (position CRUD in `server/positions`, CSV import/export, cron jobs in `server/market-data`, analytics modules) to call resolver and persist UUIDs.
- Ensure market data handlers request provider-specific aliases via resolver before hitting external APIs.

## Phase 4 – Client & API Updates

- Update API routes and React components consuming symbol data to expect `{ id, ticker, aliases[] }`, adjusting queries in `app/(routes)` pages and `components/feature` tables.
- Audit hooks/utils (`hooks/use-symbols`, `utils/symbol-format`) for ticker assumptions; expose canonical UUID to client where needed while keeping ticker for display.
- Update CSV export/import formats to include ticker for users but rely on UUID internally.

## Phase 5 – Testing, Verification & Rollout

- Extend automated tests (unit + e2e) covering resolver alias resolution, position creation, market data updates, and CSV workflows with renamed tickers.
- Run smoke tests on staging: migrations, backfill, cron jobs, dashboard views, analytics, AI tools.
- Document rollback plan (backup legacy ticker PK, revert migrations) and craft deployment checklist for low-traffic window (Phase 4 of plan doc).
- Communicate schema/API changes to contributors; update `README.md` and plan doc with migration status.

### To-dos

- [ ] Finalize schema changes and downstream dependency inventory for symbols UUID refactor.
- [ ] Implement migrations for UUID primary keys, alias table, and foreign key backfills.
- [ ] Regenerate Supabase types and update shared TS/Zod definitions for symbols and aliases.
- [ ] Create resolver module and update server data flows to use UUID-based symbol lookups.
- [ ] Update client/UI layers, CSV tooling, and tests; perform staging verification and rollout prep.
